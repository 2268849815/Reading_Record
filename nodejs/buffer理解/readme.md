# buffer 
使用buffer直接 newBuffer(str, 'utf-8')
给元素复制小于0， 就将该值逐次加256， 直到得到0-255之间的整数。 如果得到的数值大于255， 就逐次减256， 直到得到0-255区间的数值。如果是小数，舍弃小数部分，保留整数部分
Buffer对象的内存分配不是在v8堆内存中，实在nodec++层面实现内存的申请的。因为要处理大量的字节数据，向操作系统申请内存可能造成大量内存申请的系统调用
为了高效地使用申请来的内存， node采用slab分配机制
# slab三种状态 （一块申请好的固定大小的内存区域)
- full: 完全分配状态
- partial: 部分分配状态
- empty: 没有被分配状态
new Buffer(size) Node以8kb为界限来区分Buffer是大对象还是小对象
isEncoding()函数来判断编码是否支持转换

# 乱码形成的原因
因为读取文件流时就是读取buffer字节，但是buffer是有长度的，例如每次读取buffer的长度限制为11，但是中文字在UTF-8的tostring()方法下占三个字节，所以每次读取buffer都只能读三个字，而第四个字只能读取两个字节，不能型成中文字，只能乱码的形式显示，以此类推，第二个buffer就是3+3+3+2，第四个字又是乱码.....
# setEncoding()
这个方法作用是让data时间中传递的不再是一个Buffer对象，而是编码后的字符串 setEncoding(utf-8) 可读流对象在内部设置了一个decoder对象。每次data时间都通过这个对象进行buffer到字符串的解码，然后传递给调用者，这个对象负责接收buffer传递来的编码并且吧不完整的编码留下来，和下一次的编码拼接显示，这样就不会乱码，但是目前只能处理UTF-8, Base64,UCS-2/UTF-16LE三种编码
